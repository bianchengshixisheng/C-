#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//统计，将数值转换为二进制位后，其中包含的1的个数
//int mian()
//{
//	int num = 0;
//	int count = 0;//统计值
//	printf("请输入一个数值:>");
//	scanf("%d",num);
//	//由于数值存放在内存中是以二进制的形式存放的，所有采用遍历
//	int i = 0;
//	//由于此处的数值是整形，所有最多32位二进制位
//	for (i=0; i<32; i++)
//	{
//		if(1 == ((num >> 1) & 1))
//			count++;
//	}
//	printf("%d\n",count);
//	return 0;
//}

//连续赋值
//int main()
//{
//	////法一
//	//int y = 10;
//	//int x = 0;
//	//int a = 0;
//	//x = y + 1;
//	//a = x;
//
//	//法二
//	int y = 10;
//	int x = 0;
//	int a = 0;
//	a = x = y + 1;
//	
//
//	return 0;
//}



//sizeof计算大小
//int main()
//{
//	int a = 10;
//	char c = 'r';
//	char* p = &c;
//	int arr[10] = { 0 };
//	//sizeof 计算变量所占内存空间的大小，单位是字节
//	printf("%d\n",sizeof(a));//4
//	printf("%d\n",sizeof(int));//4
//
//	printf("%d\n",sizeof(c));//1
//	printf("%d\n",sizeof(char));//1
//
//	printf("%d\n",sizeof(p));//4
//	printf("%d\n",sizeof(char*));//4
//
//	printf("%d\n",sizeof(arr));//40
//	printf("%d\n",sizeof(int [10]));//40
//
//	return 0;
//}



 
//坑例题
//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d\n",sizeof(s = a + 5));//2  虽然a值的类型是int整形，但是将a+5放入的是short中，而short类型的大小最大是2个字节，所有为2.
//	printf("%d\n",s);//0  在sizeof中的s=a+5并不会对全局造成影响，不会改变s的取值，所有s为0
//	return 0;
//}



//~号的作用
//
//int main()
//{
//	int a = 0;
//	//00000000000000000000000000000000   0的二进制形式  以补码的形式存储
//	//~按位取反
//	//11111111111111111111111111111111    取反后的补码
//	//11111111111111111111111111111110	  取反后的反码
//	//10000000000000000000000000000001	  取反后的源码	数据显示的形式
//	//	最终值 -1
//	printf("%d\n",~a);
//
//	return 0;
//}




//int main()
//{
//	int a = 11;
//	a = a | (1 << 2);
//	printf ("%d\n",a);
//	// 11 的二进制形式：
//	//00000000000000000000000000001011
//	//若要将第三位的值更改位1，则	采用按位或
//	//00000000000000000000000000001011
//	//00000000000000000000000000000100		而此处的形成采用位移的方式
//	//	将(1 << 2)
//	//00000000000000000000000000001111		最终为15
//
//	a = a & (~(1 << 2));
//	printf("%d\n",a);
//	//将其返回至11
//	//00000000000000000000000000001111
//	//若要将其返回值11，采用按位与
//	//11111111111111111111111111111011
//	//而要得到它就需要取反
//	//00000000000000000000000000000100		需要的值
//	//11111111111111111111111111111011		取反后的值
//	//0100的值需要位移的到
//	//  将(~(1 << 2))
//	return 0;
//}


